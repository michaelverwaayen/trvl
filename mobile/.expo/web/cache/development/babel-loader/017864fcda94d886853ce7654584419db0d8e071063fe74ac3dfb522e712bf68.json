{"ast":null,"code":"import { computeNextBackoffInterval } from '@ide/backoff';\nimport * as Application from 'expo-application';\nimport { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nconst updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\nexport async function updateDevicePushTokenAsync(signal, token) {\n  const doUpdateDevicePushTokenAsync = async retry => {\n    const [development, deviceId] = await Promise.all([shouldUseDevelopmentNotificationService(), getDeviceIdAsync()]);\n    const body = {\n      deviceId: deviceId.toLowerCase(),\n      development,\n      deviceToken: token.data,\n      appId: Application.applicationId,\n      type: getTypeOfToken(token)\n    };\n    try {\n      const response = await fetch(updateDevicePushTokenUrl, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json'\n        },\n        body: JSON.stringify(body),\n        signal\n      });\n      if (!response.ok) {\n        console.debug('[expo-notifications] Error encountered while updating the device push token with the server:', await response.text());\n      }\n      if (!response.ok) {\n        retry();\n      }\n    } catch (error) {\n      if (typeof error === 'object' && error?.name === 'AbortError') {\n        return;\n      }\n      console.warn('[expo-notifications] Error thrown while updating the device push token with the server:', error);\n      retry();\n    }\n  };\n  let shouldTry = true;\n  const retry = () => {\n    shouldTry = true;\n  };\n  let retriesCount = 0;\n  const initialBackoff = 500;\n  const backoffOptions = {\n    maxBackoff: 2 * 60 * 1000\n  };\n  let nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n  while (shouldTry && !signal.aborted) {\n    shouldTry = false;\n    await doUpdateDevicePushTokenAsync(retry);\n    if (shouldTry && !signal.aborted) {\n      nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n      retriesCount += 1;\n      await new Promise(resolve => setTimeout(resolve, nextBackoffInterval));\n    }\n  }\n}\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError('ERR_NOTIFICATIONS_DEVICE_ID', `Could not fetch the installation ID of the application: ${e}.`);\n  }\n}\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    default:\n      return devicePushToken.type;\n  }\n}\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {}\n  }\n  return false;\n}","map":{"version":3,"names":["computeNextBackoffInterval","Application","CodedError","Platform","UnavailabilityError","ServerRegistrationModule","updateDevicePushTokenUrl","updateDevicePushTokenAsync","signal","token","doUpdateDevicePushTokenAsync","retry","development","deviceId","Promise","all","shouldUseDevelopmentNotificationService","getDeviceIdAsync","body","toLowerCase","deviceToken","data","appId","applicationId","type","getTypeOfToken","response","fetch","method","headers","JSON","stringify","ok","console","debug","text","error","name","warn","shouldTry","retriesCount","initialBackoff","backoffOptions","maxBackoff","nextBackoffInterval","aborted","resolve","setTimeout","getInstallationIdAsync","e","devicePushToken","OS","notificationServiceEnvironment","getIosPushNotificationServiceEnvironmentAsync"],"sources":["/Users/michaelverwaayen/RFQ/mobile/node_modules/expo-notifications/src/utils/updateDevicePushTokenAsync.ts"],"sourcesContent":["import { computeNextBackoffInterval } from '@ide/backoff';\nimport * as Application from 'expo-application';\nimport { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nimport { DevicePushToken } from '../Tokens.types';\n\nconst updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\n\nexport async function updateDevicePushTokenAsync(signal: AbortSignal, token: DevicePushToken) {\n  const doUpdateDevicePushTokenAsync = async (retry: () => void) => {\n    const [development, deviceId] = await Promise.all([\n      shouldUseDevelopmentNotificationService(),\n      getDeviceIdAsync(),\n    ]);\n    const body = {\n      deviceId: deviceId.toLowerCase(),\n      development,\n      deviceToken: token.data,\n      appId: Application.applicationId,\n      type: getTypeOfToken(token),\n    };\n\n    try {\n      const response = await fetch(updateDevicePushTokenUrl, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      // Help debug erroring servers\n      if (!response.ok) {\n        console.debug(\n          '[expo-notifications] Error encountered while updating the device push token with the server:',\n          await response.text()\n        );\n      }\n\n      // Retry if request failed\n      if (!response.ok) {\n        retry();\n      }\n    } catch (error: any) {\n      // Error returned if the request is aborted should be an 'AbortError'. In\n      // React Native fetch is polyfilled using `whatwg-fetch` which:\n      // - creates `AbortError`s like this\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L505\n      // - which creates exceptions like\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L490-L494\n      if (typeof error === 'object' && error?.name === 'AbortError') {\n        // We don't consider AbortError a failure, it's a sign somewhere else the\n        // request is expected to succeed and we don't need this one, so let's\n        // just return.\n        return;\n      }\n\n      console.warn(\n        '[expo-notifications] Error thrown while updating the device push token with the server:',\n        error\n      );\n\n      retry();\n    }\n  };\n\n  let shouldTry = true;\n  const retry = () => {\n    shouldTry = true;\n  };\n\n  let retriesCount = 0;\n  const initialBackoff = 500; // 0.5 s\n  const backoffOptions = {\n    maxBackoff: 2 * 60 * 1000, // 2 minutes\n  };\n  let nextBackoffInterval = computeNextBackoffInterval(\n    initialBackoff,\n    retriesCount,\n    backoffOptions\n  );\n\n  while (shouldTry && !signal.aborted) {\n    // Will be set to true by `retry` if it's called\n    shouldTry = false;\n    await doUpdateDevicePushTokenAsync(retry);\n\n    // Do not wait if we won't retry\n    if (shouldTry && !signal.aborted) {\n      nextBackoffInterval = computeNextBackoffInterval(\n        initialBackoff,\n        retriesCount,\n        backoffOptions\n      );\n      retriesCount += 1;\n      await new Promise((resolve) => setTimeout(resolve, nextBackoffInterval));\n    }\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_DEVICE_ID',\n      `Could not fetch the installation ID of the application: ${e}.`\n    );\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"],"mappings":"AAAA,SAASA,0BAA0B,QAAQ,cAAc;AACzD,OAAO,KAAKC,WAAW,MAAM,kBAAkB;AAC/C,SAASC,UAAU,EAAEC,QAAQ,EAAEC,mBAAmB,QAAQ,mBAAmB;AAE7E,OAAOC,wBAAwB,MAAM,6BAA6B;AAGlE,MAAMC,wBAAwB,GAAG,mDAAmD;AAEpF,OAAO,eAAeC,0BAA0BA,CAACC,MAAmB,EAAEC,KAAsB;EAC1F,MAAMC,4BAA4B,GAAG,MAAOC,KAAiB,IAAI;IAC/D,MAAM,CAACC,WAAW,EAAEC,QAAQ,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAChDC,uCAAuC,EAAE,EACzCC,gBAAgB,EAAE,CACnB,CAAC;IACF,MAAMC,IAAI,GAAG;MACXL,QAAQ,EAAEA,QAAQ,CAACM,WAAW,EAAE;MAChCP,WAAW;MACXQ,WAAW,EAAEX,KAAK,CAACY,IAAI;MACvBC,KAAK,EAAErB,WAAW,CAACsB,aAAa;MAChCC,IAAI,EAAEC,cAAc,CAAChB,KAAK;KAC3B;IAED,IAAI;MACF,MAAMiB,QAAQ,GAAG,MAAMC,KAAK,CAACrB,wBAAwB,EAAE;QACrDsB,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE;SACjB;QACDX,IAAI,EAAEY,IAAI,CAACC,SAAS,CAACb,IAAI,CAAC;QAC1BV;OACD,CAAC;MAGF,IAAI,CAACkB,QAAQ,CAACM,EAAE,EAAE;QAChBC,OAAO,CAACC,KAAK,CACX,8FAA8F,EAC9F,MAAMR,QAAQ,CAACS,IAAI,EAAE,CACtB;MACH;MAGA,IAAI,CAACT,QAAQ,CAACM,EAAE,EAAE;QAChBrB,KAAK,EAAE;MACT;IACF,CAAC,CAAC,OAAOyB,KAAU,EAAE;MAOnB,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,EAAEC,IAAI,KAAK,YAAY,EAAE;QAI7D;MACF;MAEAJ,OAAO,CAACK,IAAI,CACV,yFAAyF,EACzFF,KAAK,CACN;MAEDzB,KAAK,EAAE;IACT;EACF,CAAC;EAED,IAAI4B,SAAS,GAAG,IAAI;EACpB,MAAM5B,KAAK,GAAGA,CAAA,KAAK;IACjB4B,SAAS,GAAG,IAAI;EAClB,CAAC;EAED,IAAIC,YAAY,GAAG,CAAC;EACpB,MAAMC,cAAc,GAAG,GAAG;EAC1B,MAAMC,cAAc,GAAG;IACrBC,UAAU,EAAE,CAAC,GAAG,EAAE,GAAG;GACtB;EACD,IAAIC,mBAAmB,GAAG5C,0BAA0B,CAClDyC,cAAc,EACdD,YAAY,EACZE,cAAc,CACf;EAED,OAAOH,SAAS,IAAI,CAAC/B,MAAM,CAACqC,OAAO,EAAE;IAEnCN,SAAS,GAAG,KAAK;IACjB,MAAM7B,4BAA4B,CAACC,KAAK,CAAC;IAGzC,IAAI4B,SAAS,IAAI,CAAC/B,MAAM,CAACqC,OAAO,EAAE;MAChCD,mBAAmB,GAAG5C,0BAA0B,CAC9CyC,cAAc,EACdD,YAAY,EACZE,cAAc,CACf;MACDF,YAAY,IAAI,CAAC;MACjB,MAAM,IAAI1B,OAAO,CAAEgC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,mBAAmB,CAAC,CAAC;IAC1E;EACF;AACF;AAGA,eAAe3B,gBAAgBA,CAAA;EAC7B,IAAI;IACF,IAAI,CAACZ,wBAAwB,CAAC2C,sBAAsB,EAAE;MACpD,MAAM,IAAI5C,mBAAmB,CAAC,8BAA8B,EAAE,wBAAwB,CAAC;IACzF;IAEA,OAAO,MAAMC,wBAAwB,CAAC2C,sBAAsB,EAAE;EAChE,CAAC,CAAC,OAAOC,CAAC,EAAE;IACV,MAAM,IAAI/C,UAAU,CAClB,6BAA6B,EAC7B,2DAA2D+C,CAAC,GAAG,CAChE;EACH;AACF;AAGA,SAASxB,cAAcA,CAACyB,eAAgC;EACtD,QAAQA,eAAe,CAAC1B,IAAI;IAC1B,KAAK,KAAK;MACR,OAAO,MAAM;IACf,KAAK,SAAS;MACZ,OAAO,KAAK;IAEd;MACE,OAAO0B,eAAe,CAAC1B,IAAI;EAC/B;AACF;AAGA,eAAeR,uCAAuCA,CAAA;EACpD,IAAIb,QAAQ,CAACgD,EAAE,KAAK,KAAK,EAAE;IACzB,IAAI;MACF,MAAMC,8BAA8B,GAClC,MAAMnD,WAAW,CAACoD,6CAA6C,EAAE;MACnE,IAAID,8BAA8B,KAAK,aAAa,EAAE;QACpD,OAAO,IAAI;MACb;IACF,CAAC,CAAC,MAAM,CAER;EACF;EAEA,OAAO,KAAK;AACd","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}