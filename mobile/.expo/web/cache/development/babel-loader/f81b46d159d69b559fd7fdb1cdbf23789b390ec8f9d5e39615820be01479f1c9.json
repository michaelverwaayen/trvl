{"ast":null,"code":"import { CodedError } from 'expo-modules-core';\nconst GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nlet googleApiKey;\nexport function setGoogleApiKey(apiKey) {\n  googleApiKey = apiKey;\n}\nexport async function googleGeocodeAsync(address) {\n  assertGoogleApiKey();\n  const result = await requestGoogleApiAsync({\n    address\n  });\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(geocodingResultToLocation);\n}\nexport async function googleReverseGeocodeAsync(options) {\n  assertGoogleApiKey();\n  const result = await requestGoogleApiAsync({\n    latlng: `${options.latitude},${options.longitude}`\n  });\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(reverseGeocodingResultToAddress);\n}\nfunction assertGeocodeResults(resultObject) {\n  const {\n    status,\n    error_message\n  } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(status, 'the request could not be processed due to a server error. The request may succeed if you try again.');\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error('Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.');\n  }\n}\nasync function requestGoogleApiAsync(params) {\n  const query = Object.entries(params).map(entry => `${entry[0]}=${encodeURI(entry[1])}`).join('&');\n  const result = await fetch(`${GOOGLE_API_URL}?key=${googleApiKey}&${query}`);\n  return await result.json();\n}\nfunction geocodingResultToLocation(result) {\n  const {\n    location\n  } = result.geometry;\n  return {\n    latitude: location.lat,\n    longitude: location.lng\n  };\n}\nfunction reverseGeocodingResultToAddress(result) {\n  const address = {};\n  for (const {\n    long_name,\n    short_name,\n    types\n  } of result.address_components) {\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_number')) {\n      address.streetNumber = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address;\n}","map":{"version":3,"names":["CodedError","GOOGLE_API_URL","googleApiKey","setGoogleApiKey","apiKey","googleGeocodeAsync","address","assertGoogleApiKey","result","requestGoogleApiAsync","status","assertGeocodeResults","results","map","geocodingResultToLocation","googleReverseGeocodeAsync","options","latlng","latitude","longitude","reverseGeocodingResultToAddress","resultObject","error_message","Error","params","query","Object","entries","entry","encodeURI","join","fetch","json","location","geometry","lat","lng","long_name","short_name","types","address_components","includes","city","district","streetNumber","street","region","subregion","country","isoCountryCode","postalCode","name","formatted_address","replace"],"sources":["/Users/michaelverwaayen/RFQ/mobile/node_modules/expo-location/src/LocationGoogleGeocoding.ts"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\n\nimport { LocationGeocodedAddress, LocationGeocodedLocation } from './Location.types';\n\nconst GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nlet googleApiKey;\n\ntype GoogleApiGeocodingAddressComponent = {\n  long_name: string;\n  short_name: string;\n  types: string[];\n};\n\ntype GoogleApiGeocodingResult = {\n  address_components: GoogleApiGeocodingAddressComponent[];\n  formatted_address: string;\n  geometry: {\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n};\n\ntype GoogleApiGeocodingResponse = {\n  results: GoogleApiGeocodingResult[];\n  status: string;\n};\n\n// @needsAudit\n/**\n * Sets a Google API Key for using Google Maps Geocoding API which is used by default on Web\n * platform and can be enabled through `useGoogleMaps` option of `geocodeAsync` and `reverseGeocodeAsync`\n * methods. It might be useful for Android devices that do not have Google Play Services, hence no\n * Geocoder Service.\n * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`\n * enabled, otherwise your geocoding requests will be denied.\n */\nexport function setGoogleApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nexport async function googleGeocodeAsync(address: string): Promise<LocationGeocodedLocation[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({ address });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(geocodingResultToLocation);\n}\n\nexport async function googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<LocationGeocodedAddress[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({\n    latlng: `${options.latitude},${options.longitude}`,\n  });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(reverseGeocodingResultToAddress);\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n/**\n * Makes sure the Google API key is set.\n */\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error(\n      'Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.'\n    );\n  }\n}\n\n/**\n * Generic and handy method for sending requests to Google Maps API endpoint.\n */\nasync function requestGoogleApiAsync(\n  params: { address: string } | { latlng: string }\n): Promise<GoogleApiGeocodingResponse> {\n  const query = Object.entries(params)\n    .map((entry) => `${entry[0]}=${encodeURI(entry[1])}`)\n    .join('&');\n  const result = await fetch(`${GOOGLE_API_URL}?key=${googleApiKey}&${query}`);\n  return await result.json();\n}\n\n/**\n * Converts Google's result to the location object.\n */\nfunction geocodingResultToLocation(result: GoogleApiGeocodingResult): LocationGeocodedLocation {\n  const { location } = result.geometry;\n  return {\n    latitude: location.lat,\n    longitude: location.lng,\n  };\n}\n\n/**\n * Converts Google's result to address object.\n */\nfunction reverseGeocodingResultToAddress(\n  result: GoogleApiGeocodingResult\n): LocationGeocodedAddress {\n  const address: Partial<LocationGeocodedAddress> = {};\n\n  for (const { long_name, short_name, types } of result.address_components) {\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_number')) {\n      address.streetNumber = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address as LocationGeocodedAddress;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}