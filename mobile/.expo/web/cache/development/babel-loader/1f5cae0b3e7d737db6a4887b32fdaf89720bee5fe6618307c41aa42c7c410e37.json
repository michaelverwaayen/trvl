{"ast":null,"code":"import 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\nlet lastAbortController = null;\nasync function updatePushTokenAsync(token) {\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\nexport async function setAutoServerRegistrationEnabledAsync(enabled) {\n  lastAbortController?.abort();\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n  await ServerRegistrationModule.setRegistrationInfoAsync(enabled ? JSON.stringify({\n    isEnabled: enabled\n  }) : null);\n}\nexport async function __handlePersistedRegistrationInfoAsync(registrationInfo) {\n  if (!registrationInfo) {\n    return;\n  }\n  let registration = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.', e);\n  }\n  if (!registration?.isEnabled) {\n    return;\n  }\n  try {\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', e);\n  }\n}\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  addPushTokenListener(async token => {\n    try {\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync();\n      if (!registrationInfo) {\n        return;\n      }\n      const registration = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', e);\n    }\n  });\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(`[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`, new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync'));\n}","map":{"version":3,"names":["UnavailabilityError","ServerRegistrationModule","addPushTokenListener","getDevicePushTokenAsync","updateDevicePushTokenAsync","updateDevicePushTokenAsyncWithSignal","lastAbortController","updatePushTokenAsync","token","abort","AbortController","signal","setAutoServerRegistrationEnabledAsync","enabled","setRegistrationInfoAsync","JSON","stringify","isEnabled","__handlePersistedRegistrationInfoAsync","registrationInfo","registration","parse","e","console","warn","latestDevicePushToken","getRegistrationInfoAsync","then"],"sources":["/Users/michaelverwaayen/RFQ/mobile/node_modules/expo-notifications/src/DevicePushTokenAutoRegistration.fx.ts"],"sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * @hidden - the comment is misleading and the purpose of the function needs to be reevaluated\n *\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param enabled\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n// note(Chmiela): This function is exported only for testing purposes.\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async (token) => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"mappings":"AAAA,OAAO,2BAA2B;AAClC,SAASA,mBAAmB,QAAQ,mBAAmB;AAEvD,OAAOC,wBAAwB,MAAM,4BAA4B;AACjE,SAASC,oBAAoB,QAAQ,gBAAgB;AAErD,OAAOC,uBAAuB,MAAM,2BAA2B;AAC/D,SAASC,0BAA0B,IAAIC,oCAAoC,QAAQ,oCAAoC;AAEvH,IAAIC,mBAAmB,GAA2B,IAAI;AACtD,eAAeC,oBAAoBA,CAACC,KAAsB;EAExDF,mBAAmB,EAAEG,KAAK,EAAE;EAC5BH,mBAAmB,GAAG,IAAII,eAAe,EAAE;EAC3C,OAAO,MAAML,oCAAoC,CAACC,mBAAmB,CAACK,MAAM,EAAEH,KAAK,CAAC;AACtF;AAgBA,OAAO,eAAeI,qCAAqCA,CAACC,OAAgB;EAG1EP,mBAAmB,EAAEG,KAAK,EAAE;EAE5B,IAAI,CAACR,wBAAwB,CAACa,wBAAwB,EAAE;IACtD,MAAM,IAAId,mBAAmB,CAAC,0BAA0B,EAAE,0BAA0B,CAAC;EACvF;EAEA,MAAMC,wBAAwB,CAACa,wBAAwB,CACrDD,OAAO,GAAGE,IAAI,CAACC,SAAS,CAAC;IAAEC,SAAS,EAAEJ;EAAO,CAAE,CAAC,GAAG,IAAI,CACxD;AACH;AAGA,OAAO,eAAeK,sCAAsCA,CAC1DC,gBAA2C;EAE3C,IAAI,CAACA,gBAAgB,EAAE;IAErB;EACF;EAEA,IAAIC,YAAY,GAAuC,IAAI;EAC3D,IAAI;IACFA,YAAY,GAAGL,IAAI,CAACM,KAAK,CAACF,gBAAgB,CAAC;EAC7C,CAAC,CAAC,OAAOG,CAAC,EAAE;IACVC,OAAO,CAACC,IAAI,CACV,wGAAwG,EACxGF,CAAC,CACF;EACH;EAEA,IAAI,CAACF,YAAY,EAAEH,SAAS,EAAE;IAE5B;EACF;EAEA,IAAI;IAGF,MAAMQ,qBAAqB,GAAG,MAAMtB,uBAAuB,EAAE;IAC7D,MAAMI,oBAAoB,CAACkB,qBAAqB,CAAC;EACnD,CAAC,CAAC,OAAOH,CAAC,EAAE;IACVC,OAAO,CAACC,IAAI,CACV,0GAA0G,EAC1GF,CAAC,CACF;EACH;AACF;AAEA,IAAIrB,wBAAwB,CAACyB,wBAAwB,EAAE;EAGrDxB,oBAAoB,CAAC,MAAOM,KAAK,IAAI;IACnC,IAAI;MAIF,MAAMW,gBAAgB,GAAG,MAAMlB,wBAAwB,CAACyB,wBAAyB,EAAE;MAEnF,IAAI,CAACP,gBAAgB,EAAE;QAErB;MACF;MAEA,MAAMC,YAAY,GAAuCL,IAAI,CAACM,KAAK,CAACF,gBAAgB,CAAC;MACrF,IAAIC,YAAY,EAAEH,SAAS,EAAE;QAG3B,MAAMV,oBAAoB,CAACC,KAAK,CAAC;MACnC;IACF,CAAC,CAAC,OAAOc,CAAC,EAAE;MACVC,OAAO,CAACC,IAAI,CACV,0GAA0G,EAC1GF,CAAC,CACF;IACH;EACF,CAAC,CAAC;EAKFrB,wBAAwB,CAACyB,wBAAwB,EAAE,CAACC,IAAI,CAACT,sCAAsC,CAAC;AAClG,CAAC,MAAM;EACLK,OAAO,CAACC,IAAI,CACV,2IAA2I,EAC3I,IAAIxB,mBAAmB,CAAC,0BAA0B,EAAE,0BAA0B,CAAC,CAChF;AACH","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}